面向对象的编程,并不是类越多越好,类的划分是为了封装,但分类的基础是抽象,具有相同属性和功能的对象的抽象集合才是类.
比如打一折和打九折只是形式不同,抽象分析出来,所有的打折算法都是一样的,所以打折算法应该是一个类.
简单工厂的模式是,需要在工厂类内部做判断,从而创建相应的产品
这个模式的实现是:一个产品模式基类,然后用子类去继承基类实现不同的产品类. 然后构建工厂类,在工厂类中判断条件,选择
使用哪个产品子类(返回new一个子类). 通常,这个判断还是用的switch

简单工厂模式只能解决对象的创建问题.所以牵扯到会较频繁改动创建. 策略模式定义了算法家族,分别封装起来,让它们之间
可以相互替换,此模式让算法的变化,不会影响到客户.

=========突然之间的顿悟========
以前老听说接口接口,一直理解是函数传参的形参,在C语言里这个理解似乎并无大碍
但是刚刚!!我在看策略模式的时候,突然明白过来,在Cpp中,基类做接口是多么的巧夺天工!!!!
怎么说,基类可以被不同功能的子类继承,而妙在基类的对象是可以直接使用子类的,所以,就可以用一个指针实现不同的类的
选择!!!!!
类的定义与与继承的原因

策略模式的策略类层次为Context定义了一系列可供重用的算法或行为,继承有助于析取出这些算法的公共功能.
另外策略模式的优点是简化了单元测试,因为每个算法都有自己的类,可以通过自己的单独接口测试.
当不同的行为堆砌在一个类中时,就很难避免使用条件语句来选择合适的行为.将这些行为封装在一个个独立的策略类中,可以
在使用这些行为的类中消除条件语句
策略模式是用来封装算法的,但在实践中,它几乎可以封装任何类型的规则,制药在分析过程中听到需要在不同时间应用不同的
业务规则,就可以考虑使用策略模式处理这种变化的可能性

SRP单一原则:就一个类而言,应该仅有一个引起它变化的原因
如果一个类承担的职责过多,就等于把这些职责耦合在一起,一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力.
这种耦合会导致脆弱的设计,当发生变化时,设计会遭受到意想不到的破坏[ASD]

OCP开放-封闭原则:是说软件实体(类,模块,函数等等)应该可以扩展,但是不可修改
强内聚,松耦合
依赖倒转原则:
    A.高层模块不应该依赖底层模块.两个都应该依赖抽象
    B.抽象不应该依赖细节,细节应该依赖抽象
LSP里氏代换原则:一个软件实体如果使用的是一个父类的话,那么一定适用于其子类,而且它觉察不出父类和子类对象的区别.
也就是说,在软件里面,把父类都替换成它的子类,程序的行为没有变化.子类型必须能够替换掉它们的父类型.
        正是因为这个原则,是的继承复用成为可能,只有当子类可以替换掉父类,软件单位功能不受影响时,父类才能真正被
        复用,而子类也能够在父类的基础上增加新的行为.


装饰原则:动态的给一个对象添加一些额外的职责,就增加功能来说,装饰模式比生成子类更为灵活
            通俗来说,我们需要把所需的功能按正确的顺序串联起来进行控制
        Component是定义一个对象接口,可以给这些对象动态地添加职责.ConcreteComponent是定义了一个具体的对象,也可以给
        这个对象添加一些职责.Decorator,装饰抽象类,继承了Component,从外类来扩展Component类的功能,但对于Component来
        说,是无需知道到Decorator的存在的.至于ConcreteDecorator就是具体的装饰对象,起到给Component添加职责的功能.

代理模式:为其他对象提供一种代理以控制对这个对象的访问
        设计一个接口类,在这个接口类中,new一个源类,在客户端调用接口类的方法,接口类方法内部调用源类函数.

工厂方法模式:定义一个用于创建对象的接口,让子类决定实例化哪一个类.工厂方法使一个类的实例化延迟到其子类
    工厂方法模式实现时,客户端需要决定实例化哪一个工厂来实现运算类,选择判断的问题还是存在的,也就是说,工厂方法把简单
    工厂的内部逻辑判断移到了客户端代码来进行,你想要加功能,本来是改工厂类的,而现在是修改客户端



